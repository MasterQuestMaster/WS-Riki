---
import MainLayout from "@layouts/MainLayout.astro";
import SearchHeader from "@layouts/SearchHeader.astro";
import CardGrid from "@components/CardGrid.astro";
import CardList from "@components/CardList.astro";
import type GridCardModel from "src/models/GridCardModel";
import type ListCardModel from "src/models/ListCardModel";

import { db, Card, Set, eq } from 'astro:db';
import { QueryParser, type IKeywordOptions as QueryKeywordOptions } from "@scripts/parser/queryParser";
import { DrizzleParser, type IKeywordOptions as DrizzleKeywordOptions } from "@scripts/parser/drizzleParser";
import { stringifyLogicTree, getSingleToken } from "@scripts/parser/logicGroup";
import { stringifySearchToken, objectMap } from "@scripts/utils";
import { getColumnFromString } from "@scripts/db-utils";

import parserConfig from "src/config/parser-config.json";
import displayConfig from "src/config/display-config.json";
import OrderSelect from "@components/controls/OrderSelect.astro";
import DisplaySelect from "@components/controls/DisplaySelect.astro";



const query = Astro.url.searchParams.get("q");

//Perform a runtime check for the default value, since TS convert is only compile time.
let displayFormat = Astro.url.searchParams.get("as")?.toLowerCase() ?? "";
if(!Object.hasOwn(displayConfig, displayFormat)) {
    displayFormat = "image";
}

//Parse the query into a LogicTree that can be processed further.
const parser = new QueryParser(parserConfig.keywords as QueryKeywordOptions);
//TODO: Show errors as error message below search bar on result page.
let tree = parser.parse(query);
console.log(stringifyLogicTree(tree, stringifySearchToken));


//Parse the Logic Tree from the Query Parser into a Drizzle "Where" clause.
const drizzleConfig = parserConfig.keywords as DrizzleKeywordOptions;
const drizzleParser = new DrizzleParser(drizzleConfig);
//TODO: error handling for the possible exceptions here.
const drizzleFilterParams =  drizzleParser.parseLogicTree(tree);

//Check if a search for only a single set was made. If so, redirect to /sets/...
const singleToken = getSingleToken(tree);
if(singleToken?.type == "expression" && singleToken.keyword == "set") {
    //check if exactly 1 set that fits the criteria exists.
    const setResults = await db.select({id: Set.id}).from(Set).where(drizzleFilterParams);

    if(setResults.length == 1) {
        const setid = setResults[0].id;
        return Astro.redirect(`/sets/${encodeURIComponent(setid)}?as=${encodeURIComponent(displayFormat)}`);
    }
}

//Check if we have any keywords that require joining of the "Set" table.
// const usedSetKeywords = Object.keys(drizzleConfig).filter((key) => {
//     const dbCol = drizzleConfig[key].dbColumn;
//     const isSetKeyword = Array.isArray(dbCol) ? dbCol.find(c=>c.startsWith("Set")) : dbCol.startsWith("Set");
//     return isSetKeyword && drizzleParser.statistics.keywordUsage[key];
// });

//IMPORTANT: The result structure changes if we include a join.
//It becomes {Card:{id,name,...},Set:{id,name,...}}.
//We can avoid this by specifying all the columns in the Select.

//"any" type is necessary because SelectedFields type is not compatible.
//TODO: Maybe get rid of displayconfig since we join set always and we can't use CardModel then?
const currentDisplayConfig = displayConfig[displayFormat as keyof typeof displayConfig];
const selectColumns = objectMap<string,any>(currentDisplayConfig.select, getColumnFromString);

//Always join Set unless we find out it impacts performance.
let dbQuery = db.select(selectColumns)
    .from(Card)
    .innerJoin(Set, eq(Set.id, Card.setId));

//If the Set table is in the WHERE or in the SELECT, join it.
// if(usedSetKeywords.length > 0 || currentDisplayConfig.join?.includes("Set")) {
//     dbQuery.innerJoin(Set, eq(Set.id, Card.setId));
// }

const results = await dbQuery.where(drizzleFilterParams);
console.log("Results:" + JSON.stringify(results));
console.log(dbQuery.toSQL());

//Redirect directly to the card detail page if only 1 result is found.
if(results.length == 1) {
    const cardid = results[0].id;
    return Astro.redirect(`/card/${encodeURIComponent(cardid)}`);
}

---
<MainLayout title={query}>
    <SearchHeader searchText={query} />
    <pre>{ stringifyLogicTree(tree, stringifySearchToken) }</pre>
    <pre>{ dbQuery.toSQL().sql }</pre>
    <nav class="search-controls">
        <div class="inner-flex">
            <div class="display-options">
                <DisplaySelect id="as" value={displayFormat} />
                <OrderSelect id="order" />

                <label class="visually-hidden" for="direction">Direction</label> 
                <select name="direction" id="direction">
                    <option value="asc" selected>Asc</option> 
                    <option value="desc">Desc</option>
                </select>
            </div>
            <div class="pagination">
                <span aria-hidden="true" class="button disabled icon-only">
                    <!-- TODO: Add Icons here -->
                    <b>|&lt;</b>
                </span>
                <span aria-hidden="true" class="button disabled">
                    <b>&lt; Previous</b>
                </span>
                <a href="/search?as=image&amp;order=name&amp;page=2&amp;q=t%3Acreature&amp;unique=cards" class="button">
                    <b>Next 60 &gt;</b>
                </a>
                <a href="/search?as=image&amp;order=name&amp;page=263&amp;q=t%3Acreature&amp;unique=cards" class="button icon-only">
                    <b>&gt;|</b>
                </a>
            </div>
        </div>
    </nav>
    <main>
        <div class="search-info">
            <p>
            <strong>1 – X of {results.length} cards</strong>
            <span class="search-summary">where the card types include “creature”</span>
            </p>
        </div>
        <!-- Display the correct markup depending on the display format. -->
        {displayFormat == "image" && <CardGrid cards={results as GridCardModel[]} />}
        {displayFormat == "list" && <CardList cards={results as ListCardModel[]} />}
    </main>
    
    <!-- TODO: Show a default page if no cards were found. -->
</MainLayout>

<style>
    .search-controls {
        padding: 12px 2.5%;
        background-color: #F6F4FA;
        background-color: #F3F5F8;
        border-bottom: 1px solid rgba(99,68,150,0.1);
    }

    .search-controls .inner-flex {
        flex-flow: row nowrap;
        justify-content: space-between;
        align-items: center;
    }

    .display-options, .pagination {
        display: flex;
        flex-flow: row nowrap;
        justify-content: flex-start;
        align-items: center;
    }

    .search-info {
        background-color: #F6F4FA;
        padding: 8px 2.5%;
        font-size: 12px;
        color: #535353;
        border-bottom: 1px solid rgba(99,68,150,0.1);
        text-align: center;
        display: block;

        & p {
            display: block;
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
        }

        & strong {
            color: #000;
            font-weight: 500;
        }
    }

    @media screen and (min-width: 760px) {
        .search-info {
            padding: 10px 2.5%;
            font-size: 14px;
            text-align: left;
        }
    }
</style>